const path=require("path"),fs=require("fs"),zlib=require("zlib"),utilsTool=require("./utils"),encoding=utilsTool.encoding,cachedApis={},slashReg=/^\/|\/$/g,semReg=/\s*;\s*$/,metaReg=/^\s*\/\*([\s\S]*?)\*\//m,isMockDataReg=/^\s*(?:function|\{)/,getMockDataFromFilePath=(pathName,params,request,response)=>{if(!fs.existsSync(pathName))return{writeHead:[500],output:[pathName+" file is not existed~",encoding]};{let mtime=fs.statSync(pathName).mtime.getTime(),cachedApi=cachedApis[pathName];if(!cachedApi||cachedApi.mtime!==mtime)try{let content=new String(fs.readFileSync(pathName,encoding),encoding).trim(),matched=!0;for(;matched;)matched=!1,content=content.replace(metaReg,(all,contents)=>(matched=!0,""));content=content.replace(semReg,""),isMockDataReg.test(content)&&(content="return ("+content+")");let result=Function(content)();cachedApis[pathName]=cachedApi={result:result,mtime:mtime}}catch(e){try{return{writeHead:[200],output:[fs.readFileSync(pathName,"binary"),"binary"]}}catch(e){return{writeHead:[500],output:[e.message,encoding],parser:JSON.stringify.bind(JSON)}}}let result=cachedApi.result;"function"==typeof result&&(result=result(params,{require:require,request:request,response:response,__dirname:path.resolve(pathName,".."),tools:{}}));const sleep=result.sleep;if(isNaN(sleep))return{writeHead:[200,{"Content-Type":"text/plain;charset="+encoding}],output:[result,encoding],parser:JSON.stringify.bind(JSON)};try{let copy=JSON.parse(JSON.stringify(result));return delete copy.sleep,{writeHead:[200,{"Content-Type":"text/plain;charset="+encoding}],output:[copy,encoding],parser:JSON.stringify.bind(JSON),sleep:sleep}}catch(e){return{writeHead:[200,{"Content-Type":"text/plain;charset="+encoding}],output:[{code:500,url:reqUrl,e:e},encoding],parser:JSON.stringify.bind(JSON)}}}},getMockPath=(pathName,options)=>{let mockPath=options.mockConfig&&options.mockConfig.path||"mock";const rules=[].concat(options.rules),len=rules.length;for(let i=0;i<len;i++){let rule=new RegExp(rules[i]),isApi=!1;if(pathName.replace(rule,match=>{const parts=(pathName=pathName.replace(match,"_").replace(/^_|_$/,"")).replace(slashReg,"").split(/\//);pathName=path.resolve(mockPath,match.replace(slashReg,"").replace(/\//g,"_"),parts.join("_")),isApi=!0}),isApi)break}return pathName+=options.mockConfig&&options.mockConfig.ext||".js"},doMock=(pathName,request,response,params,options)=>{try{pathName=getMockPath(pathName,options);const result=getMockDataFromFilePath(pathName,params,request,response);isNaN(result.sleep)?(response.writeHead.apply(response,result.writeHead),response.end.apply(response,result.output.map((item,idx)=>0===idx&&result.parser?result.parser(item):item))):setTimeout(()=>{response.writeHead.apply(response,result.writeHead),response.end.apply(response,result.output.map((item,idx)=>0===idx&&result.parser?result.parser(item):item))},result.sleep)}catch(e){response.writeHead(500),response.end(JSON.stringify(e.message))}},fillMissingMock=(pathName,data,options)=>{try{if(pathName=getMockPath(pathName,options),!fs.existsSync(pathName)){let response;response="gzip"===data.headers["content-encoding"]?JSON.stringify(JSON.parse(zlib.unzipSync(data.buffer).toString()),null,2):JSON.stringify(JSON.parse(data.buffer.toString()),null,2),fs.mkdirSync(pathName.replace(/\/[^/]+$/,""),{recursive:!0}),fs.writeFile(pathName,response,{encoding:encoding,flags:"w+"},e=>{console.log(e)})}}catch(e){console.log(e)}};module.exports={doMock:doMock,fillMissingMock:fillMissingMock};