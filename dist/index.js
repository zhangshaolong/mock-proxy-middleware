"use strict";const queryString=require("querystring"),URL=require("url"),http=require("http"),https=require("https"),path=require("path"),fs=require("fs"),encoding="UTF-8",proxyReg=/^([^:]+):(\d+)$/,cachedApis={},showProxyLog=(options,method,redirectUrl,data)=>{data.length>2e3?console.log(`proxy request: \n\tHost:${options.host}\n\tPort:${options.port}\n\tMethod:${method}\n\tPath:${redirectUrl}\n\tParams:too large not display`):console.log(`proxy request: \n\tHost:${options.host}\n\tPort:${options.port}\n\tMethod:${method}\n\tPath:${redirectUrl}\n\tParams:${data}`)},proxyData=(original,callback)=>{let chunks=[],size=0;original.on("data",chunk=>{chunks.push(chunk),size+=chunk.length}),original.on("end",()=>{let data=null,len=chunks.length;switch(len){case 0:data=new Buffer(0);break;case 1:data=chunks[0];break;default:data=new Buffer(size);for(let i=0,pos=0;i<len;i++){let chunk=chunks[i];chunk.copy(data,pos),pos+=chunk.length}}callback(data)})},writeResponse=(proxyRes,res,encoding)=>{let headers=proxyRes.headers,statusCode=proxyRes.statusCode;try{if(headers)for(let key in headers)res.setHeader(key,headers[key]);res.writeHead(statusCode)}catch(e){console.log("setHeader error",e.message)}proxyData(proxyRes,data=>{res.end(data,encoding)})};module.exports=(opts=>{let proxyInfo;return(req,res,next)=>{const apiConfig=opts.apiConfig,ignoreProxyPaths=opts.ignoreProxyPaths||{},mockPath=opts.mockPath||"mock";proxyInfo=opts.proxyInfo||proxyInfo;const reqUrl=req.url,withoutArgUrl=reqUrl.split(/\?/)[0],apiType=apiConfig.type,apiValue=apiConfig.value;"string"==typeof apiValue&&(apiValue=[apiValue]);const len=apiValue.length;let isApi=!1;if("prefix"===apiType){for(let i=0;i<len;i++)if(0===reqUrl.indexOf(apiValue[i])){isApi=!0;break}}else if("suffix"===apiType)for(let i=0;i<len;i++)if(withoutArgUrl.endsWith(apiValue[i])){isApi=!0;break}if(!isApi)return next();{const headers={},method=req.method.toUpperCase(),urlInfo=URL.parse(reqUrl,!0),contentType=req.headers["content-type"]||"text/plain;charset=UTF-8",isHttps="https"===req.protocol,getProxyInfo=()=>{const pageUrl=req.headers.referer;if(pageUrl){const query=URL.parse(pageUrl,!0).query;if(query&&query.proxy){const pair=query.proxy.replace(/^https?\:\/\//,"").split(":");return{host:pair[0],port:pair[1]||(isHttps?443:80)}}}},doProxy=proxyInfo=>{let redirectUrl=reqUrl;proxyInfo.redirect&&(redirectUrl=proxyInfo.redirect(reqUrl)),headers.host=proxyInfo.host+":"+proxyInfo.port,headers["Content-Type"]=contentType;const options={host:proxyInfo.host,port:proxyInfo.port||(isHttps?443:80),path:redirectUrl,method:req.method,timeout:3e4,headers:headers},proxy=postData=>{headers.contentLength=postData.length;let proxyReq=(isHttps?https:http).request(options,proxyRes=>{writeResponse(proxyRes,res,"UTF-8")});proxyReq.on("error",e=>{res.end(JSON.stringify({status:500,e:e.message})),console.log("proxyReq error: "+e.message)}),proxyReq.end(postData,"UTF-8")};let postData="";"POST"===method?(req.on("error",e=>{console.log("req error: "+e.message)}),req.body?(postData=contentType&&contentType.indexOf("application/x-www-form-urlencoded")>-1?queryString.stringify(req.body):JSON.stringify(req.body),proxy(postData),showProxyLog(options,method,redirectUrl,postData)):proxyData(req,data=>{proxy(data),showProxyLog(options,method,redirectUrl,data)})):"GET"===method&&(postData=JSON.stringify(urlInfo.query),proxy(postData),showProxyLog(options,method,redirectUrl,postData))};for(let key in req.headers)headers[key]=req.headers[key];if(proxyInfo||(proxyInfo=getProxyInfo()),proxyInfo&&proxyInfo.host&&!ignoreProxyPaths[withoutArgUrl])return void doProxy(proxyInfo);if(proxyReg.test(ignoreProxyPaths[withoutArgUrl]))return void doProxy({host:RegExp.$1,port:RegExp.$2||(isHttps?443:80)});const doMock=(params,pathName)=>{try{params.__url__&&(pathName=params.__url__,delete params.__url__);let slashReg=/^\/|\/$/g;for(let i=0;i<len;i++)if(pathName["prefix"===apiType?"startsWith":"endsWith"](apiValue[i])){const parts=(pathName=pathName.replace(apiValue[i],"")).replace(slashReg,"").split(/\//);pathName=path.resolve(mockPath,apiValue[i].replace(slashReg,"").replace(/\//g,"_"),parts.join("_"));break}pathName+=".js",fs.exists(pathName,exist=>{if(exist){let mtime=fs.statSync(pathName).mtime.getTime(),cachedApi=cachedApis[pathName];if(!cachedApi||cachedApi.mtime!==mtime)try{let content=new String(fs.readFileSync(pathName,"UTF-8"),"UTF-8").trim();content=content.replace(/^\s*(?:\<meta\>[\s\S]*?<\/meta\>\s*)?/im,""),/^(?:function|\{)/.test(content)&&(content="return "+content);let result=Function(content)();cachedApis[pathName]=cachedApi={result:result,mtime:mtime}}catch(e){try{const content=fs.readFileSync(pathName,"binary");res.writeHead(200),res.write(content,"binary"),res.end()}catch(e){res.writeHead(500),res.end(JSON.stringify(e.message))}return}let result=cachedApi.result;"function"==typeof result&&(result=result(params)),res.writeHead(200,{"Content-Type":"text/plain;charset=UTF-8"}),isNaN(result.sleep)?("string"!=typeof result&&(result=JSON.stringify(result)),res.end(result,"UTF-8")):setTimeout(()=>{let copy=JSON.parse(JSON.stringify(result));delete copy.sleep,res.end(JSON.stringify(copy),"UTF-8")},result.sleep)}else res.writeHead(500),res.end(pathName+" file is not existed~")})}catch(e){try{result=json.parse(result),res.end(result)}catch(e){res.writeHead(500),res.end(JSON.stringify(e.message))}}};let params="";"POST"===method?req.body?(params=contentType.indexOf("application/x-www-form-urlencoded")>-1?queryString.parse(req.body):JSON.parse(req.body),doMock(params,urlInfo.pathname)):proxyData(req,data=>{params=contentType.indexOf("application/x-www-form-urlencoded")>-1?queryString.parse(String(data,"UTF-8")):JSON.parse(data),doMock(params,urlInfo.pathname)}):"GET"===method&&doMock(urlInfo.query,urlInfo.pathname)}}});